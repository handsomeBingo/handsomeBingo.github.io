<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Bin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="Bin">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Bin">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bin">
  
    <link rel="alternate" href="/atom.xml" title="Bin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">发上等愿，结中等缘，享下等福；择高处立，寻平处住，向宽处行；</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gulp入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/22/gulp入门/" class="article-date">
  <time datetime="2016-11-22T13:12:20.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/22/gulp入门/">gulp入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;用gulp有一段时间了，有个朋友让我给他说说gulp，所以今天就写一篇关于gulp的文章做做分享。<br>在我的文章中，我在介绍一个东西之前都会说一说这个东西诞生的背景，亦或者说这个东西诞生是为了解决什么问题。每次技术的进步都是从未知到已知，从发现问题，到认识问题，最后解决问题的，我之所以介绍这些背景，其实是在理顺这些思路，是在为后面的逻辑铺路，在学习一门新的技术的时候，我们也应该是这样一种思路：这门技术是解决什么问题的，这门技术又是如何解决的这个问题。所以说每当遇到问题时，要想清楚到底是哪里出了问题，只有这样，靶向解决问题才能指标治本。当然，在解决问题时，难的不是解决，时发现问题的根源所在！我记得我在学习这门语言的时候，我遇到过很多困惑的地方，老师问我到底是哪里不懂，我说：“如果我能说出我哪里不懂，其实距离懂只差一层窗户纸额的距离。”很显然，发现问题的根源远比解决问题更难，希望大家在学习技术的时候，遇到问题，不能理解的时候，或者觉得和自己“以为”的不一样时，千万记得找出你心里的疑惑究竟是在哪儿，只有把这个疑惑解决了，问题才算是真正解决了；好了，说了一大堆，还是回来说说gulp吧。<br>1、    什么是gulp？<br>gulp是可以自动化执行任务的工具 在平时开发的流程里面,一定有一些任务需要手工重复得执行，比如:<br>&#160; &#160; &#160; &#160;    把文件从开发目录拷贝到生产目录<br>&#160; &#160; &#160; &#160;    把多个 JS 或者 CSS 文件合并成一个文件<br>&#160; &#160; &#160; &#160;    对JS文件和CSS进行压缩<br>&#160; &#160; &#160; &#160;    把sass或者less文件编译成CSS<br>&#160; &#160; &#160; &#160;    压缩图像文件<br>&#160; &#160; &#160; &#160;只要你觉得有些动作是要重复去做的,就可以把这些动作创建成一个gulp任务 然后在指定的条件下自动执行 比如在less源文件发生改变后自动编译成css文件；但是这些改变时建立在监视基础之上的，下面将会讲述这一特殊的机制。<br>gulp是基于node.js的，建议大家在阅读这篇文章的时候，对nodejs有一定的了解，如果你还不是很了解，建议阅读前面的有关nodejs基础和node.js进阶的一些知识，因为gulp大多是文件的IO操作，大家在看node.js的基础的时候，重点记忆有关于fs模块、fs中的流。<br>2、gulp的特点<br>&#160; &#160; &#160; &#160;利用 node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。前一级的输出，直接变成后一级的输入，使得在操作上非常简单。此外gulp还提供了高质量的插件， Gulp 严格的插件指南确保插件如你期望的那样简洁地工作。<br>这里要提出注意的地方是gulp的流（Stream）又和node.js中的流（Stream）不大一样，因为node中的流逝二进制流，gulp的流是文件流，文件流不仅仅包含了文件的内容，还包含了文件的的文件名和路径。但是这两种流都是分为可读流和可写流；<br>此外，gulp最大的优势在于其类似jquery的链式写法，上一级操作的输出，直接变成下一级的输入，后面将为大家展示。<br>3、实现思路：<br>&#160; &#160; &#160; &#160;gulp的核心原理就是先创建一个可读流，然后通过pipe方法导出，然乎经过各个插件的加工，最后创建一个可写流，写入硬盘；<br>4、gulp的核心API<br>&#160; &#160; &#160; &#160;gulp只有四个核心API，也正是这四个方法使得原来的复杂的任务简化起来，也正是由于其API简单，所以很易学。但是插件的API又是五花八门的，当然，只有需要使用插件的地方，我们在引入插件；</p>
<p>1）、<br>gulp.src(glob,[,options]);创建一个可读流<br>参数：<br>&#160; &#160; &#160; &#160;•    globs 参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组；<br>&#160; &#160; &#160; &#160;•    options 为可选参数。通常情况下我们不需要用到<br>2）、<br>gulp.dest(path[,options]) 是用来向硬盘写入文件的；<br>&#160; &#160; &#160; &#160;•    path 为写入文件的路径<br>&#160; &#160; &#160; &#160;•    options 为一个可选的参数对象，通常我们不需要用到<br>&#160; &#160; &#160; &#160;要想使用好gulp.dest()这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。gulp.dest()传入的路径参数只能用来指定要生成的文件的目录,而不能指定生成文件的文件名 它生成文件的文件名使用的是导入到它的文件流自身的文件名 所以生成的文件名是由导入到它的文件流决定的<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">  gulp.src(&apos;script/jquery.js&apos;)</span><br><span class="line">  .pipe(gulp.dest(&apos;dist/jquery.js&apos;));</span><br><span class="line">//最终生成的文件路径为 dist/jquery.js/jquery.js,而不是dist/jquery.js</span><br></pre></td></tr></table></figure>


<p>3）、gulp.task(name[, deps], fn);gulp.task方法用来定义任务;<br>&#160; &#160; &#160; &#160;•    name 为任务名称<br>&#160; &#160; &#160; &#160;•    deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数<br>•    fn 为任务定义函数，我们把任务要执行的代码都写在里面。该参数也是可选的。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;mytask&apos;, \[&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;\],</span><br><span class="line">function() &#123; //定义一个有依赖的任务</span><br><span class="line">      // Do something</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务<br>//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行；<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;one&apos;,function()&#123;</span><br><span class="line">      //one是一个异步执行的任务</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;one is done&apos;)</span><br><span class="line">      &#125;,5000);</span><br><span class="line">    &#125;);</span><br><span class="line"> gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123;</span><br><span class="line">      console.log(&apos;two is done&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">//先打印two is done然后打印one is done；</span><br></pre></td></tr></table></figure>

<p>4）、 gulp.watch(glob[, opts], tasks);//用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件拷贝等。<br>•    glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的 glob 相同。<br>•    opts 为一个可选的配置对象，通常不需要用到<br>•    tasks 为文件变化后要执行的任务，为一个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;uglify&apos;,function()&#123;</span><br><span class="line">    //do something</span><br><span class="line">  &#125;);</span><br><span class="line">gulp.task(&apos;reload&apos;,function()&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;);</span><br><span class="line"> gulp.watch(&apos;js/\*\*/\*.js&apos;, \[&apos;uglify&apos;,&apos;reload&apos;\]);</span><br></pre></td></tr></table></figure>

<p>另外一种使用方式：<br>    gulp.watch(glob[, opts, cb])<br>•    glob和 opts 参数与第一种用法相同<br>•    cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息 type属性为变化的类型，可以是 added、changed、deleted和path属性为发生变化的文件的路径<br>  gulp.watch(‘js/**/*.js’, function(event){<br>    //变化类型 added为新增,deleted为删除，changed为改变<br>    console.log(event.type);<br>   //变化的文件的路径<br>    console.log(event.path);<br>  });<br>练习：<br>1）写一个复制单个文件的方法；<br>//实现逻辑：先获取一个可读流（调用gulp.src()方法），通过管道（可读流的pipe()方法）输送到一个可写流中（调用gulp.dest()方法）；<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var gulp=require(“gulp”);</span><br><span class="line">gulp.task(“copy”,function()&#123;</span><br><span class="line">gulp.src(“./app/index.html”).pipe(gulp.dest(“dist/html”))&#125;);</span><br><span class="line">//打开命令窗口输入 gulp copy 回车；即可执行任务；此时的dist/html目录下多出一个index.html文件，该方法便成功了；</span><br></pre></td></tr></table></figure>

<p>2）写一个复制多个文件的方法，练习glob语法中的* **</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var gulp=require(“gulp”);</span><br><span class="line">gulp.task(“copy-imgs”,function()&#123;</span><br><span class="line">gulp.src(“app/img/*.&#123;jpg,png&#125;”)</span><br><span class="line">.pipe(gulp.dest(“dist/img”));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>//1、{}可以指定多个拓展名；<br>//2、* 可以匹配除路径分隔符 /以外的所有字符，“app/img/<em>.{jpg,png}”表示app/img第一级目录下的所有拓展名为jpg和png的文件；app/img/*</em>/.{jpg,png} 表示app/img/下所有目录（含子孙目录）中所有的拓展名为jpg和png的文件；</p>
<p>3）组合任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">gulp.task(&apos;copy-html&apos;,function()&#123;</span><br><span class="line">   return gulp.src(&apos;app/index.html&apos;).pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;copy-images&apos;,function()&#123;</span><br><span class="line">   return gulp.src(&apos;app/imgs/**/*.&#123;jpg,png&#125;&apos;).pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;copy-other&apos;,function()&#123;</span><br><span class="line">    return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;,&apos;app/js/*.tmp.js&apos;],&#123;base:&apos;app&apos;&#125;)</span><br><span class="line">.pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;default&apos;,[&apos;copy-html&apos;,&apos;copy-images&apos;,&apos;copy-other&apos;],function()&#123;</span><br><span class="line">    console.log(&apos;全部拷贝任务执行完毕!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4） 监听任务<br>使用 gulp 的 watch 这个方法，我们可以去监视一些文件，当这些文件发生变化的时候，立即去执行一些指定的任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line"></span><br><span class="line">    gulp.task(&apos;copy-html&apos;,function()&#123;</span><br><span class="line">        return gulp.src(&apos;app/index.html&apos;)</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    gulp.task(&apos;copy-images&apos;,function()&#123;</span><br><span class="line">        return gulp.src(&apos;app/imgs/**/*.&#123;jpg,png&#125;&apos;,&#123;base:&apos;app&apos;&#125;)</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    gulp.task(&apos;copy-other&apos;,function()&#123;</span><br><span class="line">        return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;</span><br><span class="line">        ,&apos;app/js/*.tmp.js&apos;],&#123;base:&apos;app&apos;&#125;).pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //在执行watch的时候会监控index.html文件的变化，发生变化后可以执行拷贝html的任务</span><br><span class="line">    gulp.task(&apos;default&apos;,function()&#123;</span><br><span class="line">        gulp.watch(&apos;app/index.html&apos;,[&apos;copy-html&apos;]);</span><br><span class="line">        gulp.watch(&apos;app/imgs/**/*.&#123;jpg,png&#125;&apos;,[&apos;copy-images&apos;]);</span><br><span class="line">        gulp.watch([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;</span><br><span class="line">        ,&apos;app/js/*.tmp.js&apos;],[&apos;copy-other&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/22/gulp入门/" data-id="ck3wwixv6001lmkppnv94luw1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅析js中常用的四种检测数据类型的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/22/浅析js中常用的四种检测数据类型的方法/" class="article-date">
  <time datetime="2016-10-21T16:00:59.000Z" itemprop="datePublished">2016-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/22/浅析js中常用的四种检测数据类型的方法/">浅析js中常用的四种检测数据类型的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;在js中常用的检测数据类型的方法有四种，在项目开发中，数据类型穿插在每个重要的环节中，如果巧用数据类型检测，常常会起到意想不到的效果。在bug调试过程中，当山穷水尽的时候，如果尝试检测数据类型，往往会有柳暗花明的效果。尤其在nodejs的bug调试中十分有效，因为node在io操作时常常进行数据类型的转换，可以说屡试不爽。<br>&#160; &#160; &#160; &#160;之所以在这篇文章中才讲述，数据类型的检测，是因为数据类型的检测的方法和面向对象有着千丝万缕的联系，如果你有空可以看看前面三篇文章，相信能对数据类型检测有更深的体会，正所谓磨刀不费砍柴功。闲言少叙，奔正题。<br>1、    typeof<br>typeof的应用场景大多是检测基本数据类型或者不需要具体细分的对象数据类型检测亦或者是区分基本数据类型和引用数据类型。<br>typeof的返回值是字符串包裹的被检值对应的数据类型，一共有6个，”number”、”string”、”boolean”、”undefined”、”function”、”null”、”object”。示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 	5);//”number”</span><br><span class="line">console.log(typeof 	“binary”);//”string”</span><br><span class="line">console.log(typeof 	true);//”boolean”</span><br><span class="line">console.log(typeof 	undefined);//” undefined”</span><br><span class="line">console.log(typeof  function ()&#123;&#125;);//”function”</span><br><span class="line">console.log(typeof 	null);//” object”</span><br><span class="line">console.log(typeof 	&#123;&#125;);//” object”</span><br><span class="line">console.log(typeof 	[]);//” object”</span><br><span class="line">console.log(typeof  /^\d+$/);//” object”</span><br><span class="line">………..</span><br></pre></td></tr></table></figure>

<p>从上面的例子中不难看出typeof有局限性，具体体现在：<br>1）    检测null的时候返回object<br>2）    不能具体细分对象数据类型<br>3）    函数本身不是一种数据类型，但是因为函数有许多特殊之处，这里typeof一个函数时返回一个function也是有道理的<br>2、    instanceof：<br>instanceof操作符是检测某个实例是否属于一个类，检测结果是布尔值，是，则返回true，否则返回false；<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ary=[1m,2m,23];</span><br><span class="line">console.log(ary instanceof Array);//true</span><br><span class="line">console.log(ary instanceof Object);//true</span><br><span class="line">var num=12；</span><br><span class="line">var num2=new Number(12);</span><br><span class="line">console.log(num instanceof Number);//false</span><br><span class="line">console.log(num2  instanceof  Number);//true</span><br></pre></td></tr></table></figure>

<p>但是instanceof也有其局限性，<br>1）    不能检测用字面临创建的基本数据类型的值，这是由于js是弱类型的语言，从这个角度讲，实例创建和字面量创建还是有区别的，只有通过实例创建的才算是对象；<br>2）    只要当前被检值在当前类的原型链上，检测结果就是true；<br>3）    在使用类的继承后，检测结果将不够准确；<br>3、    constructor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor是来弥补instanceof的不能检测字面量创建的数据的；</span><br><span class="line">var num=12；</span><br><span class="line">console.log(num.constructor===Number);//true</span><br><span class="line">var ary=[1,2,3];</span><br><span class="line">console.log(ary.constructor===Array);//true;</span><br><span class="line">console.log(ary.constructor===Object);//false;</span><br></pre></td></tr></table></figure>

<p>constructor虽然弥补了一部分instanceof的不足，但是其缺点仍然不可忽视:当类的原型被重写时，其原型的constructor很可能被修改，导致检测结果不准确；<br>4、    Object.prototype.toString.call();方法<br>每一种数据类型都自带一个toString()方法，但是功用却不尽相同，如数组的toString是转化成字符串的，而对象的toString是检测数据类型的。该方法返回值是一个字符串，如”[object  数据所属类]“。示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num=24;</span><br><span class="line">console.log(Object.prototype.toString.call(num));//”[object Number]”;</span><br><span class="line">var ary=[1,2,3];</span><br><span class="line">console.log(Object.prototype.toString.call(ary));//”[object Array]”;</span><br><span class="line">var reg=/^\w+$/g;</span><br><span class="line">console.log(Object.prototype.toString.call(reg));//”[object RegExp]”</span><br><span class="line">………..</span><br></pre></td></tr></table></figure>

<p>如果要求检测结果精准时推荐使用最后一种方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/22/浅析js中常用的四种检测数据类型的方法/" data-id="ck3wwixvy002dmkpp9t5im2m0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浅析js中的面向对象（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/04/浅析js中的面向对象（三）/" class="article-date">
  <time datetime="2016-10-04T09:41:13.000Z" itemprop="datePublished">2016-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/04/浅析js中的面向对象（三）/">浅析js中的面向对象（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;前面两篇文章，我们介绍了对象的一些特性以及面向对象的常见的封装方式，今天我们来继续讨论另外两个的关于面向对象中的重点:继承和多态；<br>继承是所有面向对象语言津津乐道的概念，后面讲述的继承方式大多基于原型模式、构造函数模式的，如果想更好的了解继承的概念，还希望大家好好看看上一篇文章中有关原型模式的论述。<br>&#160; &#160; &#160; &#160;本篇文章重点讨论几种常用的继承方式，并尝试从每种继承方式的优缺点，及继承之后父类的方法归属的角度探讨；</p>
<ul>
<li>原型继承：<br>&#160; &#160; &#160; &#160;原型继承的实现原理，子类的原型指向父类的一个实例；这样父类公有和私有的方法和属性都成为了子类公有的方法和属性；<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;//父类</span><br><span class="line">    this.delete=functinon(item)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.edit=function()&#123;&#125;;</span><br><span class="line">function Sub()&#123;//子类&#125;</span><br><span class="line"></span><br><span class="line">子类想调用父类的delete和edit方法，只需要将子类的原型指向父类的实例；</span><br><span class="line">Sub.prototype=new Super();//继承实现的核心代码</span><br></pre></td></tr></table></figure>

<p> &#160; &#160; 原型继承虽然操作很简单，但是应该注意以下问题；</p>
<ul>
<li><p>1、原型继承并非复制一份父类的公有和私有的属性及方法，而是让子类和父类有了原型链上的联系，实现继承之后，子类的实例的<strong>proto</strong>属性指向了父类的实例，而这个实例的<strong>proto</strong>又指向父类的原型，是这样实现的继承；</p>
</li>
<li><p>2、通过原型链来实现继承时，子类的原型实际上是变成了另一个类的实例，原来父类实例的属性顺理成章的成为了子类原型的上的属性，这是我们不可改变的；</p>
</li>
<li><p>3、通过原型继承后，子类的原型是被更换了（有人习惯称之为“修改子类原型的指向”，但是我觉得说“更换”更为形象），这样一来子类原型上的Constructor（构造函数）属性的值便成为父类的构造函数，这也是我们不愿意看到的，因此在实现继承之后，我们要手动的修改子类的构造函数属性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype.constructor=Sub;//手动修改子类的构造函数指向；</span><br></pre></td></tr></table></figure>
</li>
<li><p>call继承：<br>&#160; &#160; &#160; &#160;原型继承中，是将父类的公有和私有的方法都继承到了子类的公有的，但有时我们并不希望都继承了，很多场景下我们只需要继承某个类私有的方法即可，这时候就要用到call继承了。<br>&#160; &#160; &#160; &#160;call继承的实现原理，call方法是用来this关键字的方法，而在构造函数中的this都是当前类的实例，所以在子类的构造函数中call执行父类的构造函数（不通过new关键字），把父类构造函数中的this关键字修改为子类构造函数中的this，这样，父类实例的私有属性和方法都随着父类构造函数的执行继承到了子类的的实例身上。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;//父类</span><br><span class="line">  this.delete=functinon(item)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  Super.prototype.edit=function()&#123;&#125;;</span><br><span class="line">function Sub()&#123;//子类</span><br><span class="line">  this.generation=son;</span><br><span class="line">  Super.call(this);//call继承的实现的核心代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>混合继承：<br>&#160; &#160; &#160; &#160;原型继承是将父类的私有和公有的都变成子类的公有的，而call继承是将父类私有的变成子类私有的，那么有没有一种继承，让父类公有的变成子类公有的，父类私有的变成子类私有的?混合继承就解决了这个问题；<br>&#160; &#160; &#160; &#160;混合继承是原型继承和call继承混合，如此一来类公有的变成子类公有的，父类私有的变成子类私有。但是在子类的公有中多了一份父类私有的，但是原型查找机制是先查找子类私有，瑕不掩瑜，混合继承的优势还是很突出的。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;//父类</span><br><span class="line">  this.delete=functinon(item)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Super.prototype.edit=function()&#123;&#125;;</span><br><span class="line">Sub.prototype=new Super();//原型继承核心代码</span><br><span class="line">Sub.prototype.contructor=Sub;//修改constructor指向</span><br><span class="line">function Sub()&#123;//子类</span><br><span class="line">   this.generation=son;</span><br><span class="line">   Super.call(this);//call继承的实现的核心代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中间件继承：<br>&#160; &#160; &#160; &#160;中间件继承的实现依赖于<strong>proto</strong>属性，子类原型上的<strong>proto</strong>默认是指向Object的原型的，我们在在<strong>proto</strong>指向Object.prototype之前插入父类的原型。中间件继承其实是延长了子类的原型链，中间件继承是将父类公有的继承到了子类公有的。示例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;//父类</span><br><span class="line">  this.delete=functinon(item)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Super.prototype.edit=function()&#123;&#125;;</span><br><span class="line">function Sub()&#123;//子类</span><br><span class="line">    this.generation=son;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype.__proto__=Super.prototype;//中间件继承核心代码</span><br><span class="line"></span><br><span class="line">值得注意的是，.__proto__在ie下不兼容，所以慎重使用；</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展：<br>巧用Object.create(proObj)方法实现继承（from江外琉璃周啸天）<br>该继承方式很巧妙，利用的是这个方法的返回值是一个以proObj为原型的对象，其实现原理和中间件继承是一样的。但是在IE8- 不兼容。示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;//父类</span><br><span class="line">  this.delete=functinon(item)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Super.prototype.edit=function()&#123;&#125;;</span><br><span class="line">function Sub()&#123;//子类</span><br><span class="line">   this.generation=son;</span><br><span class="line">&#125;;</span><br><span class="line">Sub.prototype. = Object.create(Super.prototype);//核心代码</span><br><span class="line">虽然该方法不兼容，我尝试了简单模拟Object.create方法，代码如下</span><br><span class="line">function(obj)&#123;</span><br><span class="line">  function Fn()&#123;&#125;;</span><br><span class="line">  Fn.prototype=obj;</span><br><span class="line">  return new Fn();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;以上是有关于面向对象的继承，最后在说说js中面向对象的多态，多态包括重载和重写；在这里重点强调，js中不能像传统的面向对象那样实现重载，在其他语言中(如java)中，可以为一个函数编写两个定义，只要这两个定义的签名不同即可。（这句话是说，在java等后台语言中，可以定义两个同名函数，只要这两个函数的参数的类型或个数不同即可），当调用时，根据传递参数的不同，机制会自动调用方法。但是，在js中，如果定义多个同名函数，在预解释阶段就会被覆盖，以最后一个为准；在js中有一个现象类似于重载，但是绝不是重载；示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num)&#123;</span><br><span class="line">	if(typeof num===”undefined”)&#123;</span><br><span class="line"> 		return 0</span><br><span class="line">&#125;</span><br><span class="line">return num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在上面的例子中，虽然参数传与不传时结果不同，但是请大家注意中重点，重载是定义<strong>多个</strong>同名方法，当参数不同时自动调用对应方法执行，而这里是虽然参数不同，但是调用的始终都是<strong>一个</strong>sum方法；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/04/浅析js中的面向对象（三）/" data-id="ck3wwixw4002imkpp32nse026" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浅析js中的面向对象（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/25/浅析js中的面向对象（二）/" class="article-date">
  <time datetime="2016-09-25T09:13:59.000Z" itemprop="datePublished">2016-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/25/浅析js中的面向对象（二）/">浅析js中的面向对象（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160; 在上一篇文章中我从一个更深的层次介绍了对象（注：建议阅读 浅析js中的面向对象（一）），了解了对象属性的属性。那么今天我们开启第二个阶段，面向对象的封装。封装是真正意义上的面向对象实际功能的实现。在上一篇文章中，我们说过面向对象最大的优势就在于降低代码的非必要重复，提高代码的可维护性，降低服务器的压力。<br>&#160; &#160; &#160; &#160;面向对象有很多种封装方式，这里我们只探讨常用的，具有代表性的。如单例模式、工厂模式、构造函数模式以及基于构造函数的原型模式。</p>
<ul>
<li>单例模式：所谓单例模式就是把描述同一个事物（同一个效果或者方法）的属性和方法放在一个对象当中。单例模式作用是起到了分组的作用，这样一来，不同事物之间的属性或者方法即使名字相同(属性名和方法名)，也不会互相感染，种分组编写代码的方式称为单例模式。单例模式是项目开发过程中最为常用的开发方式，也是实现模块化开发的最简便的方式。我们来看看单例模式：<br>&#160; &#160; &#160; &#160;例如我们要实现一个编辑的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var edit=&#123;</span><br><span class="line">	copy:function(source,target)&#123;&#125;,</span><br><span class="line">	delete:function(target)&#123;&#125;,</span><br><span class="line">	back:function()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这些方法只需要定义一次，当我们需要使用edit中的方法时，我们只需要edit.copy(a,b);edit.delte(c)…即可，我们不需要重复定义copy和delete方法，这样便降低了代码的耦合度，而且在Node和Angular中，自定义模块导出时也常用单例模式。单例模式结合js高阶编程技巧中的惰性思想可以十分方便的封装一些小的方法库；这里简单示例：<br>&#160; &#160; &#160; &#160;例如我们要培养FE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var tools=(function()&#123;</span><br><span class="line">	var isStandarBrowser = &quot;getComputedStyle&quot; in window;</span><br><span class="line"></span><br><span class="line">    function jsonParse(jsonStr) &#123;</span><br><span class="line">        return &quot;JSON&quot; in window ? JSON.parse(jsonStr) : eval(&quot;(&quot; + jsonStr + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function listToAry(likeAry) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return Array.prototype.slice.call(likeAry, 0);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            var ary = [];</span><br><span class="line">            for (var i = 0; i &lt; likeAry.length; i++) &#123;</span><br><span class="line">            ary.push(likeAry[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getRandom(n, m) &#123;</span><br><span class="line">        n = Number(n);</span><br><span class="line">        m = Number(m);</span><br><span class="line">        if (isNaN(n) || isNaN(m)) &#123;</span><br><span class="line">            return Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &gt; m) &#123;</span><br><span class="line">            var tem = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.round(Math.random() * (m - n) + n);</span><br><span class="line">    &#125;</span><br><span class="line">	    return &#123;</span><br><span class="line">		    getRandom: getRandom,</span><br><span class="line">		    listToAry: listToAry,</span><br><span class="line">		    jsonParse：jsonParse</span><br><span class="line">		&#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>工厂模式：单例模式虽然有了命名空间，但是他是一个写死的对象，如果我们要创建一个包含方法的单例，单例就做不到了。所以工厂模式应运而生。不同于单例模式，工厂模式是把实现一个事物的代码封装到一个函数中，每当我们需要实现这个事物时，只需执行这个函数即可；示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function developeFE(student,skill)&#123;</span><br><span class="line">	    var objFE=&#123;&#125;;</span><br><span class="line">	    objFE.name=student;</span><br><span class="line">	    objFE.skill=skill;</span><br><span class="line">      return objFE；</span><br><span class="line">&#125;;</span><br><span class="line">   frontEngineer=developeFE(Binary, angular)；//将Binary培养成一个会angular的前端工程师</span><br><span class="line">   console.log(frontEngineer);//&#123;name:Binary,skill:angular&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数模式：工厂模式虽然解决了创建多个相似的对象的问题，但是却没有解决对象识别的问题，（即我们不知道对象是哪个类的实例）；这时候构造函数模式应运而生；构造函数是自定义一个类，并且通过new 运算符创建这个自定义类的实例；并且实现了实例识别，通过new A创建的实例，是A类的实例，通过new B创建的实例是B类的实例；【这里有必要强调一下，js中的类都是函数数据类型的，只不过他通过new执行是成为了一个类，但是他是一个函数的本质从未改变】；示例 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function DevelopFE(stu,skill)&#123;</span><br><span class="line">	this.name=stu;</span><br><span class="line">	this.skill=skill;</span><br><span class="line">	this.saySkill=function()&#123;alert(this.skill)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FE=new DevelopFE(Binary,nodejs);//FE是DevelopFE的一个实例；</span><br><span class="line">console.log(FE);//&#123;name:Binary,skill:nodejs, saySkill: function()&#123;alert(this.skill)&#125;;</span><br></pre></td></tr></table></figure>

<p>  构造函数中的注意事项：<br>      构造函数区别于工厂模式，首先我们不需要自己创建空对象，第二也不需要我们手动return，第三，向实例添加属性使用this关键字；通过this关键字添加的属性，默认都是enumerable（可枚举）的；<br>      构造函数创建一个实例，必须使用new操作符；使用new操作符实际是经历了四步：<br>  &#160; &#160; &#160; &#160;&lt;1&gt;创建一个新对象；<br>  &#160; &#160; &#160; &#160;&lt;2&gt;将this指向这个新对象<br>  &#160; &#160; &#160; &#160;&lt;3&gt;执行构造函数中的代码<br>  &#160; &#160; &#160; &#160;&lt;4&gt;将新对象返回<br>      构造函数中的this是当前构造函数的实例，这是实例识别的实现原理；<br>      构造函数中许可以随意return，如果return一个基本数据类型的值，实例不会改变，如果return一个引用数据类型，实例将会被返回值所替代；<br>      使用this关键字添加给实例的属性是实例的私有属性，是受命名空间的保护的，与其他实例（含当前类的实例）无关；检测私有属性的方法obj.hasOwnProperty(key);返回值是布尔值，true表示是该实例的私有属性，false则不是；</p>
<ul>
<li><p>原型模式<br>&#160; &#160; &#160; &#160;原型模式:构造函数在工作中也很常用，构造函数很完美，也很方便，但是他也不是没有缺点的，比如说在前面构造函数的例子中，每一个FE都应该具备saySkill的方法，所以这应该是一个共用的方法，没有必要每个实例身上都有一份，这说明一个问题呢?说明构造函数模式虽然解决了工厂模式的实例识别的问题，但是并没有实现面向对象中公有方法共用；这时候基于构造函数的原型模式诞生了；其实，从逻辑上来讲，我们也应该能想到：既然要方法共用，那就不应该放在实例上，应该在构造函数身上找一个公共的地方来存放这些方法，而这个公共的地方需满足实例能访问，构造函数可以访问的要求；这个地方就是原型prototype，原型定义在构造函数身上，构造函数可以通过 . 访问，实例通过<strong>proto</strong>访问；<br>如果想理解原型模式及原型链，请将下面的段落熟读5遍；<br>&#160; &#160; &#160; &#160;    每一个函数数据类型（普通函数、类），都有一个天生自带的属性prototype（原型，下称原型），并且他是一个对象数据类型的【公共的地方，定义在构造函数上】；<br>&#160; &#160; &#160; &#160;    并且在prototype上天生自带constructor(构造函数)属性，constructor的值是当前原型的类本身；<br>&#160; &#160; &#160; &#160;    每一个对象数据类型(原型，实例，普通对象)都有一个<strong>proto</strong>属性，该属性的值是一个指针，指向该实例（对象）所属类的prototype。【实例也可以找得到】<br>&#160; &#160; &#160; &#160;示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function DevelopFE(stu,skill)&#123;</span><br><span class="line">	this.name=stu;</span><br><span class="line">	this.skill=skill;</span><br><span class="line">&#125;;</span><br><span class="line">DevelopeFE.prototype.saySkill=function()&#123;alert(this.skill)&#125;;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;原型的逻辑就是这样，但是实例又是怎样访问原型的呢?这里就引入了“原型链”，原型链和作用域链很相似，都是链式查找的；<br>&#160; &#160; &#160; &#160;原型链机制：当我们调用实例的方法或者读取实例的属性时，机制会现在私有属性中查找，如果找到就读取调用；如果找不到，会读取<strong>proto</strong>的属性值，通过<strong>proto</strong>指向去实例所属类的原型上查找，找到就读取调用，如果还没找到，就通过这个类的<strong>proto</strong>指向的原型找，一直找到Object上，Objcet是所有类的基类，通俗说就是找到头了。因Object是基类，他没有<strong>proto</strong>。这里很多人可能很疑惑，类怎么也有<strong>proto</strong>，请大家不要忘记，在js中大到DOM、BOM小到key都是一个对象，所谓js中万物皆对象；<br>原型模式的注意事项：<br>&#160; &#160; &#160; &#160;    在IE中为避免我们修改原型上的属性或者方法，<strong>proto</strong>被禁用，如果我们想修改，只能用 .prototype 的方式来修改；<br>&#160; &#160; &#160; &#160;    constructor问题，在我们手动更换类的原型的时候，constructor指向也可能改变，示例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">	this.sayExprience=function(years)&#123;alert(years)&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(DevelopeFE.prototype.contructor)// DevelopeFE</span><br><span class="line">DevelopeFE. prototype=obj;</span><br><span class="line">console.log(DevelopeFE.prototype.contructor)// Object</span><br><span class="line">这并不是我们想要的，如果此时我们用constructor检测数据类型，这时结果就会出现偏差；所以如果更好原型，记得修改constructor指向；</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/25/浅析js中的面向对象（二）/" data-id="ck3wwixw6002kmkpp0w9ehl2c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浅析js中的面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/10/浅析js中的面向对象/" class="article-date">
  <time datetime="2016-09-10T13:23:22.000Z" itemprop="datePublished">2016-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/10/浅析js中的面向对象/">浅析js中的面向对象（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> &#160; &#160; &#160; &#160; 相信大家在学习js的初期都听说过一句话：js中万物皆对象；想想初期的我，还真的不是能理解，但是许多的问题如果用对象来解释就很容易理解。包括后面的angular、node.js、express都是对对象有了更为深层次应用，从这个角度阐述，我们可以理解对象究竟有多重要这里不再过多叙述，后面我还会继续分享有关angular、node.js、express的学习心得。<br> &#160; &#160; &#160; &#160; 想要面向对象，首先搞清楚，面向对象的概念是怎么提出的。面向对象是相对于以往的的面向过程变成提出的。面向过程中，为实现一个功能和效果，我们只是顺着业务逻辑写代码，不考虑代码的复用和封装的，如此一来造成页面中的代码非必要的重复，既增加了代码运行的压力，也降低了代码的可维护性。就在这样一个背景下，js中的面向对象应运而生。面向对象并不是js的专利，其他服务端语言都有这样一个概念。不同于后台的语言，由于js中没有类的概念（ES6中已经明确了类的概念，这里不阐述ES6），所以js的面向对象有有着自身十分独特的一面。<br> &#160; &#160; &#160; &#160; 前面们已经阐述过面向对象产生的背景及其意义，对象是什么？对象是一个由无序的键值对（key:value）组成的。接下来我们从更深层次认识一下对象，作为一个刚刚淌过这条小河的人来说，这十分有助于我们后面更好的理解面向对象的其他含义。<br>首先要从创建一个对象说起。创建一个对象有字面量和实例两种创建方式：</p>
<ul>
<li><p>1）字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    name:&quot;Binary&quot;,</span><br><span class="line">    age:24,</span><br><span class="line">    job:&quot;FE&quot;,</span><br><span class="line">    say:function()&#123;console.log(this.name)&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2）实例创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person=new Object();</span><br><span class="line">person.name=&quot;Binary&quot;;</span><br><span class="line">person.age=24;</span><br><span class="line">person.job=&quot;FE&quot;;</span><br><span class="line">person.say=function()&#123;console.log(this.name)&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在js中以上两种创建方式是相同的。<br> &#160; &#160; &#160; &#160; 第二，属性的类型，也可以说成是属性的属性。在对象中，每一个key不是孤零零的，在其身后也有许许多多的属性在跟随他，而他背后的这些属性规定了，是key的本质属性；key背后的属性又分成了数据属性和访问器属性；</p>
<ul>
<li>数据属性：</li>
</ul>
<ul>
<li>1）Configurable:表示能否通过delete删除该key，能否修改这个key，默认值是true；如果将该属性置位false，表示该属性不可以被删除，如果删除，在非严格模式下被忽略，严格模式下将报错。而且这个属性只能修改一次，例如，这次将age的configurable置位false，有一天你想删除它，再次将其置位true，但是同样无法删除，该操作在非严格模式下被忽略，严格模式下将报错。</li>
<li>2）Enumerable：表示该key是否可以通过for-in循环遍历到，【这个属性重点记忆】，默认值是true</li>
<li>3）Writable：表示该属性能否修改key对应的value，默认值true；当该属性置位false后，person的age属性为只读，如果修改，在非严格模式下被忽略，严格模式下将报错。</li>
<li>4）Value：包含这个属性的数据值，读取key值的时候，从这个位置读取，给key赋值的时候保存在这里；<br>  设置key的数据属性：Object.defineProperty()方法，该方法需要三个参数：第一个，key所在的对象；第二个：欲修改属性的key；第三个，描述key的对象，这个对象中的属性就是key背后的属性；示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person,&quot;age&quot;,&#123;</span><br><span class="line">    configurable:true,</span><br><span class="line">    enumerable:true,</span><br><span class="line">    writable:false,</span><br><span class="line">    value:24</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>访问器属性：<br>访问器，又称get、set器，访问器属性是不包含数据值的，get器其实就是getter函数，set器就是setter函数，那么这两个两个方法是干嘛的呢？当我们读取对象的属性值的时候，会默认调用getter函数，获取key对应的value；当我们设置值的时候，又会调用setter函数，完成设置；访问器同样也有四个属性</li>
</ul>
<ul>
<li>1）Configurable:表示能否通过delete删除该key，能否修改这个key，默认值是true；</li>
<li>2）Enumerable：表示该key是否可以通过for-in循环遍历到，默认值是true；</li>
<li>3）Get:读取属性时调用的函数，默认值undefined；</li>
<li>4）Set:设置属性时调用的函数，默认值undefined；</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    name:&quot;Binary&quot;,</span><br><span class="line">    age:24,</span><br><span class="line">    year:1992,</span><br><span class="line">    job:&quot;FE&quot;,</span><br><span class="line">    say:function()&#123;console.log(this.name)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(person,&quot;age&quot;,&#123;</span><br><span class="line">     configurable:true,</span><br><span class="line">     enumerable:true,</span><br><span class="line">     get:function()&#123;</span><br><span class="line">        return this.age</span><br><span class="line">     &#125;,</span><br><span class="line">     set:function(newVal)&#123;//通过这个方法可以在修改age的同时，让year跟着自动改变。</span><br><span class="line">        if(newVal&gt;this.age)&#123;</span><br><span class="line">            this.age=newVal;</span><br><span class="line">            this.year-=newVal+24</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">person.age=25;</span><br><span class="line">console.log(person.year);//1991;</span><br></pre></td></tr></table></figure>

<p> &#160; &#160; &#160; &#160; 以上是深层次的了解了一个对象，当然了，一般情况下工作中我们用不到这些高阶的功能，在我的印象中，只在一个node开发时用到一次get、set器，之所以写这些是为了以后更好的理解面向对象。在后面的文章中，定义一个对象的数据属性十分常用，例如enumerable属性，在后面的有关继承、构造函数模式实例识别中都有着重要意义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/10/浅析js中的面向对象/" data-id="ck3wwixw1002fmkppazzhgr8k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Vue/" style="font-size: 17.5px;">Vue</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/webpack/" style="font-size: 12.5px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/08/webpack掠影-2/">webpack掠影-2</a>
          </li>
        
          <li>
            <a href="/2019/12/07/webpack掠影-1/">webpack掠影-1</a>
          </li>
        
          <li>
            <a href="/2019/10/25/JavaScript进阶教程16/">进阶教程 16. PromiseA+</a>
          </li>
        
          <li>
            <a href="/2019/10/06/JavaScript进阶教程15/">进阶教程 15. Promise 用法详解</a>
          </li>
        
          <li>
            <a href="/2019/09/15/JavaScript进阶教程14/">进阶教程 14. 跨域和同源策略</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Mabin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>